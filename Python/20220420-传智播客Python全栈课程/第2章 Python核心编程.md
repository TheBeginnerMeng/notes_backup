# 第1节 Python核心编程

开始时间：20220421

结束时间：

## 1.1 import导入模块

import搜索模块的导入路径

```python
import sys
>>> sys.path

```

![image-20220420104944769](D:\software\Typora\images\image-20220420104944769.png)

如果想要手动添加路径，可以用`sys.path.append("xxx/path")`

## 1.2 重新导入模块

模块被导入后，使用`imp2ort xxx`不能重新导入模块，正确方式

```python
import importlib
importlib.reload(xxx)  # xxx is the module name
```

## 1.3 循环导入

两个模块分别导入对方，导致死循环导入。

防止此情况：程序设计上分层，降低耦合

## 1.4 == 和 is

is 是比较两个引用是否指向了同一个对象

== 是比较两个对象是否相等

> 在赋值整型时，Python内部作了优化处理，在`[-5, 256]`之间的整数的内存地址是固定的，并不会因为赋值给变量就开辟一块新的内存空间。

## 1.5 深拷贝、浅拷贝

浅拷贝：拷贝引用

深拷贝：复制了内容，重新开辟了一块内存空间

深拷贝用法：

```python
import copy
xx = copy.deepcopy(xx)
```

扩展：

```python
a = [11, 22, 33]
b = [44, 55, 66]
c = [a, b]

d = c  # 浅拷贝
e = copy.deepcopy(c)  # 深拷贝，此时e中的两个列表也是新生成的，并未浅拷贝a和b

f = copy.copy(c)  # 此时列表f是新生成的（id(f)和id(c)不同），但是f中的两个列表是浅拷贝的a和b
```

使用copy.copy方法时，会根据当前拷贝的数据类型有不同的处理方式，如果是可变数据类型（列表，字典），则进行深拷贝，如果是不可变数据类型，则进行浅拷贝（仅复制引用）。

## 1.6 进制、位运算

### 1.6.1 进制

进制：十进制（Decimal）、八进制（Octal）、十六进制（Hexadecimal）

### 1.6.2 有符号数和无符号数

把二进制数中的最高位（最左边的那位）用作符号位

>     对于有符号数，最高位被计算机系统规定为符号位(0为正,1为负)
>
>     对于无符号数，最高位被计算机系统规定为数据位

于是，有符号数+2和-2的原码形式为：

```
+2 = 0000 0000 0000 0010
-2 = 1000 0000 0000 0010
真值      机器数
```

> 数字在计算机中，都是按照补码的形式存储的，因此`-1 + 1`需要按照各自的补码进行相加计算

### 1.6.3 原码、反码、补码

计算补码的方法：

```
规则:
正数：原码 = 反码 = 补码
负数：反码 = 符号位不变，其他位取反
     补码 = 反码+1
     
+1的原码：0000 0000 0000 0001
-1的原码：1000 0000 0000 0001
-1的反码：1111 1111 1111 1110
-1的补码：1111 1111 1111 1111

计算-1 + 1的结果
1111 1111 1111 1111
0000 0000 0000 0001
---------------------------
0000 0000 0000 0000
```

从补码转回原码：

```
原码 = 补码的符号位不变 -->数据位取反--> 尾+1
-1的补码:1111 1111 1111 1111
    取反:1000 0000 0000 0000
-1的原码:1000 0000 0000 0001
```

拓展：

为何要使用原码, 反码和补码 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对应加减，但是对于计算机，加减乘数已经是最基础的运算, 要设计的尽量简单。计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法. 我们知道，根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.于是人们开始探索 将符号位参与运算, 并且只保留加法的方法

### 1.6.4 进制间的转换

![image-20220421104409500](![](https://blog-image-1300352669.cos.ap-beijing.myqcloud.com/img/image-20220421104409500.png)

### 1.6.5 位运算

位运算的操作符：

- & 按位与
- | 按位或
- ^ 按位异或
- ~ 按位取反
- << 按位左移
- \>> 按位右移

位运算的优点：直接操作二进制，省内存，效率高

1） 按位左移 <<

- 左移1位相当于 乘以2
- 用途：快速计算一个数乘以2的n次方 (8<<3 等同于8*2^3)

2）按位右移 >>

- 右移1位相当于 除以2
- x 右移 n 位就相当于除以2的n次方 用途:快速计算一个数除以2的n次方 (8>>3 等同于8/2^3)

3）按位与 &

```
全1才1否则0 :只有对应的两个二进位均为1时,结果位才为1,否则为0
```

4）按位或 |

```
有1就1 只要对应的二个二进位有一个为1时,结果位就为1,否则为0
```

5）按位异或  ^

```
不同为1 当对应的二进位相异(不相同)时,结果为1,否则为0
```

6）取反 ~

~9 = -10

【为什么9取反变成了-10的说明】：

9的原码 ==> 0000 1001 因为正数的原码=反码=补码，所以在 真正存储的时候就是0000 1001

接下来进行对9的补码进行取反操作

进行取反==> 1111 0110 这就是对9 进行了取反之后的补码

既然已经知道了补码，那么接下来只要转换为 咱们人能识别的码型就可以，因此按照规则 ，把这个1111 0110 这个补码 转换为原码即可

符号位不变，其它位取反==> 1000 1001

然后+1 ，得到原码 ====>1000 1010 这就是 -10

扩展：

1） 任何数和1进行&操作，得到这个数二进制形式的最低位

## 1.7 私有化

- xx: 公有变量
- _x: 单前置下划线，私有化属性或方法，from somemodule import *禁止导入，类对象和子类可以访问
- __xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)
- `__xx__`: 双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__` , __ 不要自己发明这样的名字
- xx_:单后置下划线,用于避免与Python关键词的冲突

通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。

总结

- 父类中属性名为`__`名字的，子类不继承，也不能访问
- 如果在子类中向`__`名字赋值，那么会在子类中定义一个与父类相同名字的属性
- `_`名的变量、函数、类在使用from xxx import * 时不会被导入

## 1.8 属性property

### 1.8.1 私有属性添加getter和setter方法

```python
class Money(object):
    def __init(self):
        self.__money = 0
        
    def getMoney(self):
        return self.__money
    
    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error: value is not a integer")
```

### 1.8.2 使用property升级getter和setter方法

```python
class Money(object):
    def __init(self):
        self.__money = 0
        
    def getMoney(self):
        return self.__money
    
    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error: value is not a integer")
    
    money = property(getMoney, setMoney)
```

运行结果：

```python
In [1]: from get_set import Money

In [2]: a = Money()

In [3]: a.money
Out[3]: 0

In [4]: a.money = 100

In [5]: a.money  # money当做实例属性使用
Out[5]: 100

In [6]: a.getMoney()
Out[6]: 100
```

property相当于把类的setter和getter方法进行了封装，开发者对属性设置数据的时候更方便。

### 1.8.3 使用property取代getter和setter方法

`@property`成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用：

- 将方法转换为只读
- 重新实现一个属性的设置和读取方法，可以做边界判定

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    @property
    def money(self):
        return self.__money

    @money.setter
    def money(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
```



## 第2节 Linux系统编程

## 第3节 网络编程

## 第4节 web服务器案例

## 第5节 正则表达式

